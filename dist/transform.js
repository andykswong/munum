import*as mat from"./mat.js";import*as mat4 from"./mat4.js";import*as quat from"./quat.js";import*as vec3 from"./vec3.js";import{copysign}from"./scalar.js";const v0=vec3.create();const v1=vec3.create();const v2=vec3.create();export function translate(v,out=mat4.create()){mat4.id(out);mat.copy(v,out,0,12,3);return out}export function scale(s,out=mat4.create()){mat4.id(out);out[0]=s[0];out[5]=s[1];out[10]=s[2];return out}export function rotate(q,out=mat4.create()){return quat.toMat4(q,out)}export function rotateX(theta,out=mat4.create()){mat4.id(out);out[5]=out[10]=Math.cos(theta);out[6]=out[9]=Math.sin(theta);out[9]*=-1;return out}export function rotateY(theta,out=mat4.create()){mat4.id(out);out[0]=out[10]=Math.cos(theta);out[2]=out[8]=Math.sin(theta);out[2]*=-1;return out}export function rotateZ(theta,out=mat4.create()){mat4.id(out);out[0]=out[5]=Math.cos(theta);out[1]=out[4]=Math.sin(theta);out[4]*=-1;return out}export function rotateAxis(axis,theta,out=mat4.create()){const x=axis[0],y=axis[1],z=axis[2];const s=Math.sin(theta);const c=Math.cos(theta);const omc=1-c;out[0]=x*x*omc+c;out[1]=x*y*omc+z*s;out[2]=x*z*omc-y*s;out[4]=y*x*omc-z*s;out[5]=y*y*omc+c;out[6]=y*z*omc+x*s;out[8]=z*x*omc+y*s;out[9]=z*y*omc-x*s;out[10]=z*z*omc+c;out[3]=out[7]=out[11]=out[12]=out[13]=out[14]=0;out[15]=1;return out}export function transform(translation,rotation,scaling,out=mat4.create()){rotate(rotation,out);for(let i=0;i<3;++i){for(let j=0;j<3;++j){out[4*i+j]*=scaling[i]}}mat.copy(translation,out,0,12,3);return out}export function inverseTransform(m,out=mat4.create()){mat4.transpose(m,out);out[3]=out[7]=out[11]=0;scaleOf(m,v1);for(let i=0;i<3;++i){for(let j=0;j<3;++j){out[4*i+j]*=1/(v1[j]*v1[j])}}mat.copy(vec3.mmul4(out,vec3.scale(mat.copy(m,v0,12,0,3),-1)),out,0,12,3);return out}export function translationOf(m,out=vec3.create()){return mat.copy(m,out,12,0,3)}export function scaleOf(m,out=vec3.create()){for(let i=0;i<3;++i){for(let j=0;j<3;++j){v0[j]=m[4*i+j]}out[i]=vec3.len(v0)}return out}export function rotationOf(m,out=quat.create()){scaleOf(m,v1);const m00=m[0]/v1[0],m11=m[5]/v1[1],m22=m[10]/v1[2];out[3]=Math.sqrt(Math.max(0,1+m00+m11+m22))/2;out[0]=copysign(Math.sqrt(Math.max(0,1+m00-m11-m22))/2,m[6]/v1[1]-m[9]/v1[2]);out[1]=copysign(Math.sqrt(Math.max(0,1-m00+m11-m22))/2,m[8]/v1[2]-m[2]/v1[0]);out[2]=copysign(Math.sqrt(Math.max(0,1-m00-m11+m22))/2,m[1]/v1[0]-m[4]/v1[1]);return out}export function ortho(left,right,bottom,top,znear,zfar,out=mat4.create()){const x=1/(right-left);const y=1/(top-bottom);const z=1/(znear-zfar);mat4.id(out);out[0]=2*x;out[5]=2*y;out[10]=2*z;out[12]=-(right+left)*x;out[13]=-(top+bottom)*y;out[14]=(znear+zfar)*z;return out}export function perspective(aspectRatio,yfov,znear,zfar=Infinity,out=mat4.create()){const f=1/Math.tan(yfov/2);mat4.id(out);out[0]=f/aspectRatio;out[5]=f;out[11]=-1;out[15]=0;if(isFinite(zfar)){const rangeInv=1/(znear-zfar);out[10]=(znear+zfar)*rangeInv;out[14]=2*znear*zfar*rangeInv}else{out[10]=-1;out[14]=-2*znear}return out}export function targetTo(eye,center,up=vec3.create(0,1,0),out=mat4.create()){const v=vec3.sub(eye,center,v0);vec3.norm(v,v);const n=vec3.cross(up,v,v1);vec3.norm(n,n);const u=vec3.cross(v,n,v2);vec3.norm(u,u);mat.copy(n,out,0,0,3);mat.copy(u,out,0,4,3);mat.copy(v,out,0,8,3);mat.copy(eye,out,0,12,3);out[3]=out[7]=out[11]=0;out[15]=1;return out}export function lookAt(eye,center=vec3.create(),up=vec3.create(0,1,0),out=mat4.create()){const v=vec3.sub(center,eye,v0);vec3.norm(v,v);const n=vec3.cross(v,up,v1);vec3.norm(n,n);const u=vec3.cross(n,v,v2);vec3.norm(u,u);out[0]=n[0];out[1]=u[0];out[2]=-v[0];out[4]=n[1];out[5]=u[1];out[6]=-v[1];out[8]=n[2];out[9]=u[2];out[10]=-v[2];out[12]=-vec3.dot(n,eye);out[13]=-vec3.dot(u,eye);out[14]=vec3.dot(v,eye);out[3]=out[7]=out[11]=0;out[15]=1;return out}export function direction(pitch,yaw,out=vec3.create()){const negCosPitch=-Math.cos(pitch);out[0]=negCosPitch*Math.sin(yaw);out[1]=Math.sin(pitch);out[2]=negCosPitch*Math.cos(yaw);return out}
//# sourceMappingURL=transform.js.map