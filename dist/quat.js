import*as mat from"./mat.js";import*as mat4 from"./mat4.js";import*as vec3 from"./vec3.js";import*as vec4 from"./vec4.js";import{EPSILON,fequal}from"./scalar.js";const q1=create();const q2=create();export function create(){return[0,0,0,1]}export function fromAxisAngle(axis,angle,out=create()){mat.scale(axis,Math.sin(angle/2),out);out[3]=Math.cos(angle/2);return out}export function fromAngleX(angle,out=create()){out[0]=Math.sin(angle/2);out[3]=Math.cos(angle/2);out[1]=out[2]=0;return out}export function fromAngleY(angle,out=create()){out[1]=Math.sin(angle/2);out[3]=Math.cos(angle/2);out[0]=out[2]=0;return out}export function fromAngleZ(angle,out=create()){out[2]=Math.sin(angle/2);out[3]=Math.cos(angle/2);out[0]=out[1]=0;return out}export function fromUnitVecs(from,to,out=create()){const dot=vec3.dot(from,to);if(fequal(dot,-1)){out[0]=0;out[1]=from[2];out[2]=-from[1];return fromAxisAngle(out,Math.PI,out)}else if(fequal(dot,1)){out[0]=out[1]=out[2]=0;out[3]=1;return out}vec3.cross(from,to,out);out[3]=1+dot;return norm(out,out)}export function toMat4(q,out=mat4.create()){const xx=q[0]*q[0],xy=q[0]*q[1],xz=q[0]*q[2],yy=q[1]*q[1],yz=q[1]*q[2],zz=q[2]*q[2],wx=q[3]*q[0],wy=q[3]*q[1],wz=q[3]*q[2];out[0]=1-2*(yy+zz);out[1]=2*(xy+wz);out[2]=2*(xz-wy);out[4]=2*(xy-wz);out[5]=1-2*(xx+zz);out[6]=2*(yz+wx);out[8]=2*(xz+wy);out[9]=2*(yz-wx);out[10]=1-2*(xx+yy);out[3]=out[7]=out[11]=out[12]=out[13]=out[14]=0;out[15]=1;return out}export function copy(q,out=create()){return mat.copy(q,out)}export const dot=mat.dot;export const sqrLen=vec4.sqrLen;export const len=vec4.len;export const norm=vec4.norm;export function conj(q,out=create()){out[0]=-q[0];out[1]=-q[1];out[2]=-q[2];out[3]=q[3];return out}export function invert(q,out=create()){const l=1/(sqrLen(q)||1);out[0]=-q[0]*l;out[1]=-q[1]*l;out[2]=-q[2]*l;out[3]=q[3]*l;return out}export function mul(a,b,out=create()){const ax=a[0],ay=a[1],az=a[2],aw=a[3],bx=b[0],by=b[1],bz=b[2],bw=b[3];out[0]=aw*bx+ax*bw+ay*bz-az*by;out[1]=aw*by+ay*bw+az*bx-ax*bz;out[2]=aw*bz+az*bw+ax*by-ay*bx;out[3]=aw*bw-ax*bx-ay*by-az*bz;return out}export function rotateVec3(q,v,out=vec3.create()){mat.copy(v,q1,0,0,3);q1[3]=0;mul(mul(q,q1,q1),invert(q,q2),q1);return mat.copy(q1,out,0,0,3)}export function lerp(a,b,t,out=create()){const cosTheta=dot(a,b);const magB=cosTheta<0?-1:1;out[0]=a[0]*(1-t)+b[0]*magB*t;out[1]=a[1]*(1-t)+b[1]*magB*t;out[2]=a[2]*(1-t)+b[2]*magB*t;out[3]=a[3]*(1-t)+b[3]*magB*t;return norm(out)}export function slerp(a,b,t,out=create()){let cosTheta=dot(a,b);let magB=1;if(cosTheta<0){cosTheta*=-1;magB=-1}let scale0=1-t;let scale1=t;if(1-cosTheta>EPSILON){const theta=Math.acos(cosTheta);const sinTheta=Math.sin(theta);scale0=Math.sin((1-t)*theta)/sinTheta;scale1=Math.sin(t*theta)/sinTheta}scale1*=magB;out[0]=a[0]*scale0+b[0]*scale1;out[1]=a[1]*scale0+b[1]*scale1;out[2]=a[2]*scale0+b[2]*scale1;out[3]=a[3]*scale0+b[3]*scale1;return out}
//# sourceMappingURL=quat.js.map